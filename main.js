var m=Object.defineProperty;var w=Object.getOwnPropertyDescriptor;var v=Object.getOwnPropertyNames;var F=Object.prototype.hasOwnProperty;var y=(d,l)=>{for(var e in l)m(d,e,{get:l[e],enumerable:!0})},T=(d,l,e,t)=>{if(l&&typeof l=="object"||typeof l=="function")for(let a of v(l))!F.call(d,a)&&a!==e&&m(d,a,{get:()=>l[a],enumerable:!(t=w(l,a))||t.enumerable});return d};var k=d=>T(m({},"__esModule",{value:!0}),d);var A={};y(A,{default:()=>f});module.exports=k(A);var u=require("obsidian"),f=class extends u.Plugin{constructor(){super(...arguments);this.knownFiles=new Set;this.ready=!1}async onload(){console.log("Alias on Create: loaded"),this.app.workspace.onLayoutReady(()=>{for(let e of this.app.vault.getFiles())this.knownFiles.add(e.path);console.log(`Alias on Create: ready, tracking ${this.knownFiles.size} existing files`),this.ready=!0,this.registerEvent(this.app.vault.on("create",async e=>{if(!this.ready||!(e instanceof u.TFile)||e.extension!=="md"||this.knownFiles.has(e.path))return;this.knownFiles.add(e.path);let t=e.basename;await this.waitForFileStable(e);let a=await this.findMatchingLinks(t,e);if(!a.hasLinks){console.log(`Alias on Create: no matching links found for "${t}", skipping`);return}console.log(`Alias on Create: found links for "${t}" with aliases:`,a.aliases),await this.patchBareLinks(t,e);for(let n of a.aliases)await this.addAliasViaProcessFrontMatter(e,n);await this.guardAliases(e,a.aliases)}))}),this.registerEvent(this.app.vault.on("delete",e=>{e instanceof u.TFile&&this.knownFiles.delete(e.path)})),this.registerEvent(this.app.vault.on("rename",(e,t)=>{this.knownFiles.delete(t),e instanceof u.TFile&&this.knownFiles.add(e.path)}))}onunload(){console.log("Alias on Create: unloaded")}async findMatchingLinks(e,t){let a=this.app.vault.getMarkdownFiles(),n=new Set,s=!1,i=e.replace(/[.*+?^${}()|[\]\\]/g,"\\$&"),o=new RegExp("\\[\\["+i+"(#[^\\]|]*)?(\\|([^\\]]+))?\\]\\]","g");for(let r of a){if(r.path===t.path)continue;let p=await this.app.vault.read(r);if(!p.includes(`[[${e}`))continue;let c;for(;(c=o.exec(p))!==null;){s=!0;let h=c[3]?c[3]:e;n.add(h)}}return{hasLinks:s,aliases:Array.from(n)}}async patchBareLinks(e,t){let a=this.app.vault.getMarkdownFiles(),n=0;for(let s of a){if(s.path===t.path)continue;let i=await this.app.vault.read(s);if(!i.includes(`[[${e}`))continue;let o=i.replace(/\[\[([^\]|]*?)(\|[^\]]*)?\]\]/g,(r,p,c)=>c?r:p.split("#")[0]===e?`[[${p}|${e}]]`:r);o!==i&&(await this.app.vault.modify(s,o),n++)}n>0&&console.log(`Alias on Create: patched ${n} file(s) with alias for "${e}"`)}waitForFileStable(e,t=500,a=5e3){return new Promise(n=>{let s,i=!1,o=()=>{i||(i=!0,this.app.vault.offref(r),clearTimeout(s),clearTimeout(p),n())},r=this.app.vault.on("modify",c=>{c instanceof u.TFile&&c.path===e.path&&(console.log(`Alias on Create: "${e.basename}" was modified by another plugin, resetting stabilization timer`),clearTimeout(s),s=setTimeout(o,t))});s=setTimeout(o,t);let p=setTimeout(()=>{console.log(`Alias on Create: max wait reached for "${e.basename}", proceeding`),o()},a)})}guardAliases(e,t,a=500,n=5e3){return new Promise(s=>{let i,o=!1,r=async h=>{if(!o){if(o=!0,this.app.vault.offref(p),clearTimeout(i),clearTimeout(c),h){for(let g of t)await this.addAliasViaProcessFrontMatter(e,g);console.log(`Alias on Create: re-merged aliases after external modification to "${e.basename}"`)}s()}},p=this.app.vault.on("modify",h=>{h instanceof u.TFile&&h.path===e.path&&(console.log(`Alias on Create: "${e.basename}" was modified after alias write, will re-merge`),clearTimeout(i),i=setTimeout(()=>r(!0),a))});i=setTimeout(()=>r(!1),a);let c=setTimeout(()=>{console.log(`Alias on Create: guard period ended for "${e.basename}"`),r(!1)},n)})}async addAliasViaProcessFrontMatter(e,t){await this.app.fileManager.processFrontMatter(e,a=>{a.aliases||(a.aliases=[]),typeof a.aliases=="string"&&(a.aliases=[a.aliases]),a.aliases.includes(t)||a.aliases.push(t)})}};
