var f=Object.defineProperty;var w=Object.getOwnPropertyDescriptor;var m=Object.getOwnPropertyNames;var F=Object.prototype.hasOwnProperty;var v=(o,s)=>{for(var e in s)f(o,e,{get:s[e],enumerable:!0})},y=(o,s,e,t)=>{if(s&&typeof s=="object"||typeof s=="function")for(let a of m(s))!F.call(o,a)&&a!==e&&f(o,a,{get:()=>s[a],enumerable:!(t=w(s,a))||t.enumerable});return o};var k=o=>y(f({},"__esModule",{value:!0}),o);var $={};v($,{default:()=>u});module.exports=k($);var h=require("obsidian"),u=class extends h.Plugin{constructor(){super(...arguments);this.knownFiles=new Set;this.ready=!1}async onload(){console.log("Alias on Create: loaded"),this.app.workspace.onLayoutReady(()=>{for(let e of this.app.vault.getFiles())this.knownFiles.add(e.path);console.log(`Alias on Create: ready, tracking ${this.knownFiles.size} existing files`),this.ready=!0,this.registerEvent(this.app.vault.on("create",async e=>{if(!this.ready||!(e instanceof h.TFile)||e.extension!=="md"||this.knownFiles.has(e.path))return;this.knownFiles.add(e.path);let t=e.basename;await this.waitForFileStable(e);let a=await this.findMatchingLinks(t,e);if(!a.hasLinks){console.log(`Alias on Create: no matching links found for "${t}", skipping`);return}console.log(`Alias on Create: found links for "${t}" with aliases:`,a.aliases),await this.patchBareLinks(t,e);for(let n of a.aliases)await this.addAliasViaProcessFrontMatter(e,n)}))}),this.registerEvent(this.app.vault.on("delete",e=>{e instanceof h.TFile&&this.knownFiles.delete(e.path)})),this.registerEvent(this.app.vault.on("rename",(e,t)=>{this.knownFiles.delete(t),e instanceof h.TFile&&this.knownFiles.add(e.path)}))}onunload(){console.log("Alias on Create: unloaded")}async findMatchingLinks(e,t){let a=this.app.vault.getMarkdownFiles(),n=new Set,i=!1,r=e.replace(/[.*+?^${}()|[\]\\]/g,"\\$&"),l=new RegExp("\\[\\["+r+"(#[^\\]|]*)?(\\|([^\\]]+))?\\]\\]","g");for(let p of a){if(p.path===t.path)continue;let d=await this.app.vault.read(p);if(!d.includes(`[[${e}`))continue;let c;for(;(c=l.exec(d))!==null;){i=!0;let g=c[3]?c[3]:e;n.add(g)}}return{hasLinks:i,aliases:Array.from(n)}}async patchBareLinks(e,t){let a=this.app.vault.getMarkdownFiles(),n=0;for(let i of a){if(i.path===t.path)continue;let r=await this.app.vault.read(i);if(!r.includes(`[[${e}`))continue;let l=r.replace(/\[\[([^\]|]*?)(\|[^\]]*)?\]\]/g,(p,d,c)=>c?p:d.split("#")[0]===e?`[[${d}|${e}]]`:p);l!==r&&(await this.app.vault.modify(i,l),n++)}n>0&&console.log(`Alias on Create: patched ${n} file(s) with alias for "${e}"`)}waitForFileStable(e,t=500,a=5e3){return new Promise(n=>{let i,r=!1,l=()=>{r||(r=!0,this.app.vault.offref(p),clearTimeout(i),clearTimeout(d),n())},p=this.app.vault.on("modify",c=>{c instanceof h.TFile&&c.path===e.path&&(console.log(`Alias on Create: "${e.basename}" was modified by another plugin, resetting stabilization timer`),clearTimeout(i),i=setTimeout(l,t))});i=setTimeout(l,t);let d=setTimeout(()=>{console.log(`Alias on Create: max wait reached for "${e.basename}", proceeding`),l()},a)})}async addAliasViaProcessFrontMatter(e,t){await this.app.fileManager.processFrontMatter(e,a=>{a.aliases||(a.aliases=[]),typeof a.aliases=="string"&&(a.aliases=[a.aliases]),a.aliases.includes(t)||a.aliases.push(t)})}};
